#!/usr/bin/env node
'use strict'

let https = require('https')
let path = require('path')
let os = require('os')
let fs = require('fs')
// let exec = require('child_process').exec

// const configDir = path.join(os.homedir(), 'etc')
const cacheDir = path.join(os.homedir(), '.cache', 'public-ip')
try { fs.mkdirSync(cacheDir) } catch (err) {
  // do nothing
}

process.on('uncaughtException', (err) => {
  let p = path.join(cacheDir, 'public-ip.log')
  let log = fs.createWriteStream(p)
  log.write(new Date() + '\n')
  log.write(err.stack + '\n')
  console.log(`#[fg=red]${p.replace(os.homedir(), '~')}`)
})

const minutesAgo = (minutes) => {
  let d = new Date()
  d.setMinutes(d.getMinutes() - minutes)
  return d
}

const cache = (key, fn) => {
  return function () {
    let args = Array.prototype.slice.call(arguments)
    let cb = args.pop()
    let f = path.join(cacheDir, `${key}.json`)
    fs.stat(f, (_, stat) => {
      if (stat && minutesAgo(5) < stat.mtime) {
        fs.readFile(f, (err, body) => {
          if (err) throw err
          cb.apply(null, JSON.parse(body))
        })
      } else {
        fn.apply(null, args.concat(function () {
          let args = Array.prototype.slice.call(arguments)
          fs.writeFile(f, JSON.stringify(args), (err) => {
            if (err) console.error(err)
          })
          cb.apply(null, args)
        }))
      }
    })
  }
}

let getJSON = (url, cb) => {
  https.get(url, (res) => {
    let body = ''
    res.setEncoding('utf-8')
    res
      .on('error', cb)
      .on('data', (data) => { body += data })
      .on('end', () => {
        if (res.statusCode !== 200) cb(new Error(body))
        else cb(null, body)
      })
  })
}

const getPublicIp = cache('public-ip', getJSON)

getPublicIp('https://ifconfig.me', (err, response) => {
  if (err) {
    throw err
  }
  if (response === '18.182.170.161') {
    console.log(`嬨#[fg=red,bold]${response}`)
  } else {
    console.log(` ${response}`)
  }
})
