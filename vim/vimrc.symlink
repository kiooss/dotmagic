"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => My vim config
" => Yang Yang
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => General
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
let mapleader = "\<Space>"
let maplocalleader = ","

" load plugins
source ~/.vim/plugins.vim

" Abbreviations
abbr funciton function
abbr teh the
abbr tempalte template
abbr fitler filter

set nocompatible " not compatible with vi
set autoread " detect when a file is changeed

" set mouse behavior
if has('mouse')
  " set mouse=a
  " set ttymouse=xterm2
endif

if has('nvim')
    " set clipboard=unnamedplus
else
    set clipboard=unnamed
endif

" faster redrawing
set ttyfast

set notimeout          " don't timeout on mappings
set ttimeout           " do timeout on terminal key codes
set timeoutlen=100     " timeout after 100 msec

"filetype plugin on
"filetype indent on

" make backspace behave in a sane manner
set backspace=start,indent,eol

" Tab control
" set noexpandtab " insert tabs rather than spaces for <Tab>
set expandtab
set smarttab " tab respects 'tabstop', 'shiftwidth', and 'softtabstop'
set tabstop=4 " the visible width of tabs
set softtabstop=4 " edit as if the tabs are 4 characters wide
set shiftwidth=4 " number of spaces to use for indent and unindent
set shiftround " round indent to a multiple of 'shiftwidth'
"set completeopt+=longest

" code folding settings
set foldmethod=syntax " fold based on indent
set foldnestmax=10 " deepest fold is 10 levels
set nofoldenable " don't fold by default
set foldlevel=1
set foldlevelstart=99

" set tags place
set tags=./tags,tags;

" remove the buffer limit when dong yank to copy and past in VIM
set viminfo='100,h

set cursorline

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => User Interface
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" switch syntax highlighting on
syntax on

set so=7 " set 7 lines to the cursors - when moving vertical
set hidden " current buffer can be put into background
set showcmd " show incomplete commands
set noshowmode " don't show which mode disabled for PowerLine
set wildmenu " enhanced command line completion
"set wildmode=list:longest " complete files like a shell
set wildmode=longest:list,full
set scrolloff=3 " lines of text around cursor
set shell=$SHELL
set cmdheight=1 " command bar height

set title " set terminal title

" Searching
set ignorecase " case insensitive searching
set smartcase " case-sensitive if expresson contains a capital letter
set hlsearch
set incsearch " set incremental search, like modern browsers
set nolazyredraw " don't redraw while executing macros

set magic " Set magic on, for regex

set showmatch " show matching braces
set mat=2 " how many tenths of a second to blink

" error bells
set noerrorbells
set visualbell
set t_vb=
set tm=500

" set number " show line numbers
" set relativenumber " show relative line numbers
set number " show the current line number"

set autoindent " automatically set indent of new line
set smartindent

setglobal fenc=utf-8
"set fileencodings=iso-2022-jp,euc-jp,sjis,utf-8
set fencs=utf-8,euc-jp,sjis
set enc=utf-8
set tenc=utf-8

set guifont=Droid\ Sans\ Mono\ for\ Powerline\ Nerd\ Font\ Complete\ 12

let base16colorspace=256  " Access colors present in 256 colorspace"
set t_Co=256 " Explicitly tell vim that the terminal supports 256 colors"
" set background=light
set background=dark

if has('termguicolors')
    set termguicolors
endif

" hard|medium|soft
let g:gruvbox_contrast_dark="hard"
let g:gruvbox_contrast_light="hard"
colorscheme gruvbox

" colorscheme srcery
" colorscheme solarized
" colorscheme molokai

" https://sunaku.github.io/vim-256color-bce.html
if &term =~ '256color'
  " disable Background Color Erase (BCE) so that color schemes
  " render properly when inside 256-color tmux and GNU screen.
  " see also http://snk.tuxfamily.org/log/vim-256color-bce.html
  set t_ut=
endif

set foldmethod=manual " solve autocomplete slow problem
set complete-=i
set complete+=k

""""""""
"set columns=100
"set lines=70
""""""""""""""""""""""""""""

" highlight conflicts
match ErrorMsg '^\(<\|=\|>\)\{7\}\([^=].\+\)\?$'

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => StatusLine
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set laststatus=2

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Files, backups, and undo
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"set nobackup
"set nowritebackup
"set noswapfile
set backupdir=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
set directory=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Mappings
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" Swap ; and :
" noremap ; :
" noremap : ;

" remap esc
inoremap jk <esc>
vnoremap jk <esc>
inoremap <C-e> <C-o>A

nnoremap <Leader>w :update<cr>
nnoremap <Leader>q :q<cr>
nnoremap <silent> <Leader>b :bd<cr>
nnoremap <Leader>0 :qa!<cr>
nnoremap <Leader>r :e!<cr>
nnoremap <Leader>x :x<cr>
nnoremap <Leader><Tab> <C-^>
nnoremap <Leader>p :pu<CR>
nnoremap <Leader>t :TlistToggle<CR><C-W><C-W>

nnoremap j gj
nnoremap k gk

" clear highlighted search
noremap <F3> :set hlsearch! hlsearch?<cr>

" edit ~/.vimrc
nnoremap <leader>ev :e! ~/.vimrc<cr>
nnoremap <leader>ep :e! ~/.vim/plugins.vim<cr>

" Window moving
map <C-J> <C-W>j<C-W>_
map <C-k> <C-W>k<C-W>_
map <C-h> <C-W>h<C-W>_
map <C-l> <C-W>l<C-W>_

" simplify resizing splits
if has('unix')
    nnoremap j <C-w>-
    nnoremap k <C-w>+
    nnoremap h <C-w><
    nnoremap l <C-w>>
else
    nnoremap <M-j> <C-w>-
    nnoremap <M-k> <C-w>+
    nnoremap <M-h> <C-w><
    nnoremap <M-l> <C-w>>
endif

" scroll the viewport faster
nnoremap <C-e> 3<C-e>
nnoremap <C-y> 3<C-y>

" move to beginning/end of line
nnoremap B ^
nnoremap E $

" map for command mode
" cnoremap <C-j> <t_kd>
" cnoremap <C-k> <t_ku>
cnoremap <C-a> <Home>
cnoremap <C-e> <End>

" stile select when indent in visual mode
vnoremap < <gv
vnoremap > >gv

" file type specific settings
if has('autocmd') && !exists('autocommands_loaded')
    let autocommands_loaded = 1

    autocmd FileType php set dictionary+=~/.vim/php.dict

    autocmd FileType ruby setlocal ts=2 sts=2 sw=2 expandtab
    autocmd FileType coffee setlocal ts=2 sts=2 sw=2 expandtab
    autocmd FileType crontab setlocal nobackup nowritebackup

    "ruby
    autocmd FileType ruby,eruby set omnifunc=rubycomplete#Complete
    autocmd FileType ruby,eruby let g:rubycomplete_buffer_loading = 1
    autocmd FileType ruby,eruby let g:rubycomplete_rails = 1
    autocmd FileType ruby,eruby let g:rubycomplete_classes_in_global = 1

    autocmd FileType .xml exe ":silent %!xmllint --format --recover - 2>/dev/null"

    " remove spaces at the end of line
    autocmd BufWritePre * :%s/\s\+$//e

    autocmd BufRead,BufNewFile *_js.html.erb set filetype=javascript
    autocmd BufRead,BufNewFile *_js.html.twig set filetype=javascript
    autocmd BufRead,BufNewFile *.xlsx.axlsx set filetype=ruby
    autocmd BufRead,BufNewFile *.ihtml set filetype=php
    autocmd BufRead,BufNewFile *.ejs set filetype=html
    autocmd BufRead,BufNewFile *.ino set filetype=c
    autocmd BufRead,BufNewFile *.svg set filetype=xml

    autocmd BufNewFile,BufReadPost *.md set filetype=markdown

    " automatically resize panes on resize
    autocmd VimResized * exe 'normal! \<c-w>='
    autocmd BufWritePost .vimrc source %
    autocmd BufWritePost .vimrc.local source %
    " save all files on focus lost, ignoring warnings about untitled buffers
    autocmd FocusLost * silent! wa
endif

" supertab
"let g:SuperTabMappingForward="<tab>"
"let g:SuperTabMappingBackward="<S-Tab>"
" let g:SuperTabDefaultCompletionType = "<c-n>"
let g:SuperTabDefaultCompletionType = "context"
let g:SuperTabClosePreviewOnPopupClose = 1

let g:rubycomplete_rails = 1

""" snipMate {{{
let g:snipMate = {}
let g:snipMate.scope_aliases = {}
let g:snipMate.scope_aliases['ruby'] = 'ruby,rails'

imap <C-J> <Plug>snipMateNextOrTrigger
smap <C-J> <Plug>snipMateNextOrTrigger
""" }}}

" vim-php-namespace {{{
function! IPhpInsertUse()
    call PhpInsertUse()
    call feedkeys('a',  'n')
endfunction
" autocmd FileType php inoremap <Leader>u <Esc>:call IPhpInsertUse()<CR>
autocmd FileType php noremap <Leader>u :call PhpInsertUse()<CR>

function! IPhpExpandClass()
    call PhpExpandClass()
    call feedkeys('a', 'n')
endfunction
" autocmd FileType php inoremap <Leader>e <Esc>:call IPhpExpandClass()<CR>
autocmd FileType php noremap <Leader>e :call PhpExpandClass()<CR>

" autocmd FileType php inoremap <Leader>s <Esc>:call PhpSortUse()<CR>
autocmd FileType php noremap <Leader>s :call PhpSortUse()<CR>
""" }}}

"improve autocomplete menu color
highlight Pmenu ctermbg=238 gui=bold

" toggle invisible characters
set invlist
set list
set listchars=tab:‚ñ∏\ ,extends:‚ùØ,precedes:‚ùÆ
highlight SpecialKey ctermbg=none " make the highlighting of tabs less annoying
set listchars=tab:‚ñ∏\ ,eol:¬¨
set showbreak=‚Ü™
nnoremap <leader>l :set list!<cr>

scriptencoding utf-8

" show status line
"set statusline=%<%f\ %h%m%r%=%{\"[\".(&fenc==\"\"?&enc:&fenc).((exists(\"+bomb\")\ &&\ &bomb)?\",B\":\"\").\"]\ \"}%k\ %-14.(%l,%c%V%)\ %P
"set statusline=%<%f\ %h%m%r%=%{\"[\".(&fenc==\"\"?&enc:&fenc).((exists(\"+bomb\")\ &&\ &bomb)?\",B\":\"\").\"]\ \"}%k\ %-14.(%l,%c%V%)\ \%{&ff}\ \%y\ %P

" toggle paste mode
set pastetoggle=<F2>
set showmode

" toggle line number
" nnoremap <c-l> :set number!<cr>
" inoremap <c-l> <Esc>:set number!<cr>
" Use con instead.

"Easily resize the splits"{{{
" nnoremap <C-Right> :vertical resize +5<CR>
" nnoremap <C-Left> :vertical resize -5<CR>
" nnoremap <C-Up> :res +5<CR>
" nnoremap <C-Down> :res -5<CR>
"}}}

"----------------------------------------------
" inoremap {      {}<Left>
" inoremap {<CR>  {<CR>}<Esc>O
"inoremap {{     {
" inoremap {{     {{}}<Left><Left>
inoremap {%     {%  %}<Left><Left><Left>
inoremap <%     <%  %><Left><Left><Left>
" inoremap {}     {}
"-----------------------------------------------

" save in readonly mode
cnoreabbrev w!! w !sudo tee > /dev/null %

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Plugins
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" close NERDTree after a file is opened
let g:NERDTreeQuitOnOpen=0
" show hidden files in NERDTree
let NERDTreeShowHidden=1
" remove some files by extension
let NERDTreeIgnore = ['\.js.map$']
" Toggle NERDTree
nnoremap <silent> <leader>k :NERDTreeToggle<cr>
" expand to the path of the file in the current buffer
nnoremap <silent> <leader>y :NERDTreeFind<cr>

" airline options {{{
set ttimeoutlen=50

let g:airline_powerline_fonts=1
" let g:airline_left_sep=''
" let g:airline_right_sep=''
"let g:airline_theme='luna'
"let g:airline_theme='powerlineish'
" let g:airline_theme='badwolf'
let g:airline_theme='gruvbox'
if !exists('g:airline_symbols')
  let g:airline_symbols = {}
endif
let g:airline#extensions#tabline#enabled = 1
let g:airline#extensions#hunks#enabled = 0
"let g:airline_extensions = ['ctrlp']

autocmd VimEnter,BufWinEnter *.php :AirlineRefresh
autocmd! BufWritePost .vimrc,_vimrc,vimrc
        \ source $MYVIMRC | AirlineRefresh
""" }}}

" ctrlp options {{{
let g:ctrlp_map = '<c-p>'
let g:ctrlp_cmd = 'CtrlP'

if exists("g:ctrl_user_command")
  unlet g:ctrlp_user_command
endif

let g:ctrlp_working_path_mode = 'ra'
set wildignore+=*/tmp/*,*.so,*.swp,*.zip,.rsync_cache     " MacOSX/Linux
let g:ctrlp_custom_ignore = '\v[\/]\.(git|hg|svn|rsync_cache)$'
let g:ctrlp_clear_cache_on_exit=0
let g:ctrlp_user_command = ['.git/', 'git --git-dir=%s/.git ls-files -oc --exclude-standard']
""" }}}

" show multi byte space {{{
"highlight ZenkakuSpace cterm=underline ctermfg=lightblue guibg=darkgray
"match ZenkakuSpace /„ÄÄ/
function! ZenkakuSpace()
    highlight ZenkakuSpace cterm=reverse ctermfg=DarkMagenta gui=reverse guifg=DarkMagenta
endfunction

if has('syntax')
    augroup ZenkakuSpace
        autocmd!
        autocmd ColorScheme       * call ZenkakuSpace()
        autocmd VimEnter,WinEnter * match ZenkakuSpace /„ÄÄ/
    augroup END
    call ZenkakuSpace()
endif
""" }}}

"highlight Cursor guifg=white guibg=black
"highlight iCursor guifg=white guibg=steelblue
"set guicursor=n-v-c:block-Cursor
"set guicursor+=i:ver100-iCursor
"set guicursor+=n-v-c:blinkon0
"set guicursor+=i:blinkwait10

" format array
" function! AlignPHPMap() range
"      let sep = '=>'
"      let firstline = a:firstline
"      let lastline = a:lastline
"      let lines = {}
"      for lineno in range(firstline, lastline)
"           let lines[lineno] = match(getline(lineno), '\s*' . sep)
"      endfor
"      let maxLen = max(lines) + 1
"      for lineno in range(firstline, lastline)
"           if lines[lineno] != -1
"                let spaces = repeat(' ', maxLen - lines[lineno])
"                call setline(lineno, substitute(getline(lineno), '\s*' . sep . '\s*', spaces . sep . ' ', ''))
"           endif
"      endfor
" endfunction
"
" noremap <Leader>=> :call AlignPHPMap()<CR>
"
" " format =
" function! AlignPHPAssign() range
"      let sep = '='
"      let firstline = a:firstline
"      let lastline = a:lastline
"      let lines = {}
"      for lineno in range(firstline, lastline)
"           let lines[lineno] = match(getline(lineno), '\s*' . sep)
"      endfor
"      let maxLen = max(lines) + 1
"      for lineno in range(firstline, lastline)
"           if lines[lineno] != -1
"                let spaces = repeat(' ', maxLen - lines[lineno])
"                call setline(lineno, substitute(getline(lineno), '\s*' . sep . '\s*', spaces . sep . ' ', ''))
"           endif
"      endfor
" endfunction
"
" noremap <Leader>== :call AlignPHPAssign()<CR>

function! HtmlUnEscape()
  silent s/&lt;/</eg
  silent s/&gt;/>/eg
  silent s/&amp;/\&/eg
endfunction

" nnoremap <silent> <leader>us :call HtmlUnEscape()<cr>

function! HiInterestingWord(n)
    " Save our location.
    normal! mz

    " Yank the current word into the z register.
    normal! "zyiw

    " Calculate an arbitrary match ID.  Hopefully nothing else is using it.
    let mid = 86750 + a:n

    " Clear existing matches, but don't worry if they don't exist.
    silent! call matchdelete(mid)

    " Construct a literal pattern that has to match at boundaries.
    let pat = '\V\<' . escape(@z, '\') . '\>'

    " Actually match the words.
    call matchadd("InterestingWord" . a:n, pat, 1, mid)

    " Move back to our original location.
    normal! `z
endfunction

nnoremap <silent> <leader>1 :call HiInterestingWord(1)<cr>
nnoremap <silent> <leader>2 :call HiInterestingWord(2)<cr>
nnoremap <silent> <leader>3 :call HiInterestingWord(3)<cr>
nnoremap <silent> <leader>4 :call HiInterestingWord(4)<cr>
nnoremap <silent> <leader>5 :call HiInterestingWord(5)<cr>
nnoremap <silent> <leader>6 :call HiInterestingWord(6)<cr>

hi def InterestingWord1 guifg=#000000 ctermfg=16 guibg=#ffa724 ctermbg=214
hi def InterestingWord2 guifg=#000000 ctermfg=16 guibg=#aeee00 ctermbg=154
hi def InterestingWord3 guifg=#000000 ctermfg=16 guibg=#8cffba ctermbg=121
hi def InterestingWord4 guifg=#000000 ctermfg=16 guibg=#b88853 ctermbg=137
hi def InterestingWord5 guifg=#000000 ctermfg=16 guibg=#ff9eb8 ctermbg=211
hi def InterestingWord6 guifg=#000000 ctermfg=16 guibg=#ff2c4b ctermbg=195

"----------------------------------------------------------------------------
let g:indent_guides_auto_colors=0
"autocmd VimEnter,Colorscheme * :hi IndentGuidesOdd  guibg=red   ctermbg=3
"autocmd VimEnter,Colorscheme * :hi IndentGuidesEven guibg=green ctermbg=4

"set laststatus=2 " Always display the statusline in all windows
"set showtabline=2 " Always display the tabline, even if there is only one tab
"set noshowmode " Hide the default mode text (e.g. -- INSERT -- below the statusline)

" emmet
" let g:user_emmet_expandabbr_key = '<Tab>'

"set path+=**

"let g:ackprg = 'ag --nogroup --nocolor --column'


" Vim-php-cs-fixer {{{
" If php-cs-fixer is in $PATH, you don't need to define line below
" let g:php_cs_fixer_path = "~/php-cs-fixer.phar" " define the path to the php-cs-fixer.phar
" let g:php_cs_fixer_level = "symfony"              " which level ?
let g:php_cs_fixer_level = "all"              " which level ?
" let g:php_cs_fixer_config = "default"             " configuration
"let g:php_cs_fixer_config_file = '.php_cs'       " configuration file
" let g:php_cs_fixer_php_path = "php"               " Path to PHP
" If you want to define specific fixers:
"let g:php_cs_fixer_fixers_list = "linefeed,short_tag,indentation"
let g:php_cs_fixer_enable_default_mapping = 1     " Enable the mapping by default (<leader>pcd)
let g:php_cs_fixer_dry_run = 0                    " Call command with dry-run option
let g:php_cs_fixer_verbose = 0                    " Return the output of command if 1, else an inline information.
""" }}}


"""" Neocomplete {{{
"Note: This option must set it in .vimrc(_vimrc).  NOT IN .gvimrc(_gvimrc)!
" Disable AutoComplPop.
let g:acp_enableAtStartup = 0
" Use neocomplete.
let g:neocomplete#enable_at_startup = 1
" Use smartcase.
let g:neocomplete#enable_smart_case = 1
" Set minimum syntax keyword length.
let g:neocomplete#sources#syntax#min_keyword_length = 3
let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'

" Define dictionary.
let g:neocomplete#sources#dictionary#dictionaries = {
    \ 'default' : '',
    \ 'vimshell' : $HOME.'/.vimshell_hist',
    \ 'php' : $HOME.'/.vim/php.dict',
    \ 'scheme' : $HOME.'/.gosh_completions'
        \ }

" Define keyword.
if !exists('g:neocomplete#keyword_patterns')
    let g:neocomplete#keyword_patterns = {}
endif
let g:neocomplete#keyword_patterns['default'] = '\h\w*'

" Plugin key-mappings.
inoremap <expr><C-g>     neocomplete#undo_completion()
inoremap <expr><C-l>     neocomplete#complete_common_string()

" Recommended key-mappings.
" <CR>: close popup and save indent.
inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
function! s:my_cr_function()
  return (pumvisible() ? "\<C-y>" : "" ) . "\<CR>"
  " For no inserting <CR> key.
  "return pumvisible() ? "\<C-y>" : "\<CR>"
endfunction
" <TAB>: completion.
inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
" <C-h>, <BS>: close popup and delete backword char.
inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
" Close popup by <Space>.
"inoremap <expr><Space> pumvisible() ? "\<C-y>" : "\<Space>"

" AutoComplPop like behavior.
"let g:neocomplete#enable_auto_select = 1

" Shell like behavior(not recommended).
"set completeopt+=longest
"let g:neocomplete#enable_auto_select = 1
"let g:neocomplete#disable_auto_complete = 1
"inoremap <expr><TAB>  pumvisible() ? "\<Down>" : "\<C-x>\<C-u>"

" Enable omni completion.
autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

" Enable heavy omni completion.
if !exists('g:neocomplete#sources#omni#input_patterns')
  let g:neocomplete#sources#omni#input_patterns = {}
endif
let g:neocomplete#sources#omni#input_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
"let g:neocomplete#sources#omni#input_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
"let g:neocomplete#sources#omni#input_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'

" For perlomni.vim setting.
" https://github.com/c9s/perlomni.vim
" let g:neocomplete#sources#omni#input_patterns.perl = '\h\w*->\h\w*\|\h\w*::'

let g:neocomplete#sources#omni#input_patterns.ruby = '[^. *\t]\.\h\w*\|\h\w*::'
autocmd FileType ruby setlocal omnifunc=rubycomplete#Complete
" }}}

" Prevent conflict with Neocomplete {{{
" Called once right before you start selecting multiple cursors
function! Multiple_cursors_before()
  if exists(':NeoCompleteLock')==2
    exe 'NeoCompleteLock'
  endif
endfunction

" Called once only when the multiple selection is canceled (default <Esc>)
function! Multiple_cursors_after()
  if exists(':NeoCompleteUnlock')==2
    exe 'NeoCompleteUnlock'
  endif
endfunction
" }}}

""" Shougo/deoplete.nvim {{{
let g:deoplete#enable_at_startup = 1
""" }}}

""" UltiSnips {{{
" Trigger configuration. Do not use <tab> if you use https://github.com/Valloric/YouCompleteMe.
let g:UltiSnipsExpandTrigger="<c-k>"
let g:UltiSnipsJumpForwardTrigger="<c-k>"
let g:UltiSnipsJumpBackwardTrigger="<c-j>"

" If you want :UltiSnipsEdit to split your window.
let g:UltiSnipsEditSplit="vertical"

" make vim recognizing snippets dir
" use different snippets dir
" let g:UltiSnipsSnippetsDir='~/.vim/my-snippets/'
" let g:UltiSnipsSnippetDirectories=["UltiSnips"]
""" }}}

""" godlygeek/tabular {{{
nnoremap <Leader>= :Tabularize /=>\?<CR>
vnoremap <Leader>= :Tabularize /=>\?<CR>
nnoremap <Leader>: :Tabularize /:\zs<CR>
vnoremap <Leader>: :Tabularize /:\zs<CR>
""" }}}

""" luochen1990/rainbow {{{
" let g:rainbow_active = 1
""" }}}

