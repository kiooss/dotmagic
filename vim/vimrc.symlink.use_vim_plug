"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => My vim config
" => Yang Yang
" vim: set fdm=marker fdc=1:
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => General
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"{{{
let mapleader = "\<Space>"
let maplocalleader = ","

" load plugins
source ~/.vim/plugins.vim

" Abbreviations
abbr funciton function
abbr teh the
abbr tempalte template
abbr fitler filter

set nocompatible " not compatible with vi
set autoread " detect when a file is changeed

" set mouse behavior
if has('mouse')
  " set mouse=a
  " set ttymouse=xterm2
endif

if has('nvim')
    " set clipboard=unnamedplus
else
    set clipboard=unnamed
endif

" faster redrawing
set ttyfast

set notimeout          " don't timeout on mappings
set ttimeout           " do timeout on terminal key codes
set timeoutlen=100     " timeout after 100 msec

"filetype plugin on
"filetype indent on

" make backspace behave in a sane manner
set backspace=start,indent,eol

" Tab control
" set noexpandtab " insert tabs rather than spaces for <Tab>
set expandtab
set smarttab " tab respects 'tabstop', 'shiftwidth', and 'softtabstop'
set tabstop=4 " the visible width of tabs
set softtabstop=4 " edit as if the tabs are 4 characters wide
set shiftwidth=4 " number of spaces to use for indent and unindent
set shiftround " round indent to a multiple of 'shiftwidth'
"set completeopt+=longest

" code folding settings
" set foldmethod=syntax " fold based on indent
" set foldnestmax=10 " deepest fold is 10 levels
" set nofoldenable " don't fold by default
" set foldlevel=1
" set foldlevelstart=99

" set tags place
set tags=./tags,tags;

" remove the buffer limit when dong yank to copy and past in VIM
set viminfo='100,h

set cursorline

set path+=**

" toggle paste mode
set pastetoggle=<F2>
set showmode

set laststatus=2

set wildignore+=*/tmp/*,*.so,*.swp,*.zip,.rsync_cache,.svn,.git,cache,*.phar,autocomplete.php,Tests,tests,Test,test,tmp

" save in readonly mode
cnoreabbrev w!! w !sudo tee > /dev/null %

let g:rubycomplete_rails = 1
"}}}

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => User Interface
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"{{{

" switch syntax highlighting on
syntax on

set so=7 " set 7 lines to the cursors - when moving vertical
set hidden " current buffer can be put into background
set showcmd " show incomplete commands
set noshowmode " don't show which mode disabled for PowerLine
set wildmenu " enhanced command line completion
"set wildmode=list:longest " complete files like a shell
set wildmode=longest:list,full
set scrolloff=3 " lines of text around cursor
set shell=$SHELL
set cmdheight=1 " command bar height

set title " set terminal title

" Searching
set ignorecase " case insensitive searching
set smartcase " case-sensitive if expresson contains a capital letter
set hlsearch
set incsearch " set incremental search, like modern browsers
set nolazyredraw " don't redraw while executing macros

set magic " Set magic on, for regex

set wildignorecase " case-insensitive filename completion

set showmatch " show matching braces
set mat=2 " how many tenths of a second to blink

" error bells
set noerrorbells
set visualbell
set t_vb=
set tm=500

" set number " show line numbers
" set relativenumber " show relative line numbers
set number " show the current line number"

set autoindent " automatically set indent of new line
set smartindent

setglobal fenc=utf-8
"set fileencodings=iso-2022-jp,euc-jp,sjis,utf-8
set fencs=utf-8,euc-jp,sjis
set enc=utf-8
set tenc=utf-8

"improve autocomplete menu color
highlight Pmenu ctermbg=238 gui=bold

" toggle invisible characters
set invlist
set list
set listchars=tab:‚ñ∏\ ,extends:‚ùØ,precedes:‚ùÆ
" make the highlighting of tabs less annoying
highlight SpecialKey ctermbg=none
set listchars=tab:‚ñ∏\ ,eol:¬¨
set showbreak=‚Ü™

scriptencoding utf-8

" https://sunaku.github.io/vim-256color-bce.html
if &term =~ '256color'
  " disable Background Color Erase (BCE) so that color schemes
  " render properly when inside 256-color tmux and GNU screen.
  " see also http://snk.tuxfamily.org/log/vim-256color-bce.html
  set t_ut=
endif

if has("gui_macvim")
    set guifont=Droid\ Sans\ Mono\ for\ Powerline\ Nerd\ Font\ Complete\:h14
endif

let base16colorspace=256  " Access colors present in 256 colorspace"
set t_Co=256 " Explicitly tell vim that the terminal supports 256 colors"

if has('termguicolors')
    set termguicolors
endif

" set background=light
set background=dark

" hard|medium|soft
let g:gruvbox_contrast_dark="hard"
let g:gruvbox_contrast_light="hard"
colorscheme gruvbox

" colorscheme srcery
" let g:solarized_visibility="low"
" let g:solarized_termtrans=1
" colorscheme solarized8_dark_high
" colorscheme solarized8_dark

" colorscheme molokai
" colorscheme PaperColor

set foldmethod=manual " solve autocomplete slow problem
set complete-=i
set complete+=k

" no preview window
set completeopt-=preview

"set columns=100
"set lines=70

" highlight conflicts
match ErrorMsg '^\(<\|=\|>\)\{7\}\([^=].\+\)\?$'
"}}}

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Files, backups, and undo
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"{{{
"set nobackup
"set nowritebackup
"set noswapfile
set backupdir=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
set directory=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
"}}}

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Mapping settings
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"{{{

" Swap ; and :
" noremap ; :
" noremap : ;

" enter in normal mode do nothing
nnoremap <CR> <NOP>

" remap esc
inoremap jk <esc>
inoremap <C-e> <C-o>A

nnoremap <Leader>w :w<cr>
nnoremap <Leader>q :q<cr>
nnoremap <silent> <Leader>b :bd<cr>
nnoremap <Leader>0 :qa!<cr>
nnoremap <Leader>r :e!<cr>
nnoremap <Leader>x :x<cr>
nnoremap <Leader><Tab> <C-^>
nnoremap <Leader>p :pu<CR>
nnoremap <Leader>t :TagbarToggle<CR>
nnoremap <Leader>l :set list!<CR>

nnoremap j gj
nnoremap k gk

" clear highlighted search
noremap <F3> :set hlsearch! hlsearch?<cr>

" edit ~/.vimrc
nnoremap <leader>ev :e! ~/.vimrc<cr>
nnoremap <leader>et :e! ~/.tmux.conf<cr>
nnoremap <leader>ep :e! ~/.vim/plugins.vim<cr>

" Window moving
" map <C-J> <C-W>j<C-W>_
" map <C-k> <C-W>k<C-W>_
map <C-h> <C-W>h<C-W>_
map <C-l> <C-W>l<C-W>_

" simplify resizing splits
if has('unix')
    nnoremap j <C-w>-
    nnoremap k <C-w>+
    nnoremap h <C-w><
    nnoremap l <C-w>>
else
    nnoremap <M-j> <C-w>-
    nnoremap <M-k> <C-w>+
    nnoremap <M-h> <C-w><
    nnoremap <M-l> <C-w>>
endif

" scroll the viewport faster
nnoremap <C-e> 3<C-e>
nnoremap <C-y> 3<C-y>

" move to beginning/end of line
nnoremap B ^
nnoremap E $

" map for command mode
" cnoremap <C-j> <t_kd>
" cnoremap <C-k> <t_ku>
cnoremap <C-a> <Home>
cnoremap <C-e> <End>

" stile select when indent in visual mode
vnoremap < <gv
vnoremap > >gv

" Open the definition in a vertical split
map <A-]> :vsp <CR>:exec("tag ".expand("<cword>"))<CR>

inoremap {%     {%  %}<Left><Left><Left>
inoremap <%     <%  %><Left><Left><Left>

"===============================================================================
" Normal Mode Key Mappings
"===============================================================================
" q: record macros
" w: Move word forward
" e: Move to end of word
" r: Replace single character
" t: Find till
" y: Yank. Last yank is always stored in register 0. So paste with "0p if you did a delete after the yank
" u: Undo
" i: Insert before cursor
" o: Insert line below cursor
" p: Paste


"===============================================================================
" Normal Mode Shift Key Mappings
"===============================================================================
" +/-: Increment number
nnoremap + <c-a>
nnoremap - <c-x>

"===============================================================================
" Insert Mode Ctrl Key Mappings
"===============================================================================
" Ctrl-a: Go to begin of line
inoremap <c-a> <esc>I

" Ctrl-e: Go to end of line
inoremap <c-e> <esc>A

" Ctrl-f: Move cursor left
inoremap <c-f> <Left>

" Ctrl-u: Delete til beginning of line, create undo point
inoremap <c-u> <c-g>u<c-u>




"}}}

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Autocmd settings
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" {{{
" file type specific settings
if has('autocmd') && !exists('autocommands_loaded')
    let autocommands_loaded = 1

    " php
    autocmd FileType php set dictionary+=~/.vim/php.dict
    " autocmd FileType php setlocal omnifunc=phpcomplete_extended#CompletePHP

    autocmd FileType ruby setlocal ts=2 sts=2 sw=2 expandtab
    autocmd FileType coffee setlocal ts=2 sts=2 sw=2 expandtab
    autocmd FileType crontab setlocal nobackup nowritebackup

    "ruby
    autocmd FileType ruby,eruby set omnifunc=rubycomplete#Complete
    autocmd FileType ruby,eruby let g:rubycomplete_buffer_loading = 1
    autocmd FileType ruby,eruby let g:rubycomplete_rails = 1
    autocmd FileType ruby,eruby let g:rubycomplete_classes_in_global = 1

    autocmd FileType .xml exe ":silent %!xmllint --format --recover - 2>/dev/null"

    autocmd FileType gitcommit setlocal spell

    " remove spaces at the end of line
    autocmd BufWritePre * :%s/\s\+$//e

    autocmd BufRead,BufNewFile *_js.html.erb set filetype=javascript
    autocmd BufRead,BufNewFile *_js.html.twig set filetype=javascript
    autocmd BufRead,BufNewFile *.xlsx.axlsx set filetype=ruby
    autocmd BufRead,BufNewFile *.ihtml set filetype=php
    autocmd BufRead,BufNewFile *.ejs set filetype=html
    autocmd BufRead,BufNewFile *.ino set filetype=c
    autocmd BufRead,BufNewFile *.svg set filetype=xml
    autocmd BufRead,BufNewFile *.tmuxtheme set filetype=tmux

    autocmd BufNewFile,BufReadPost *.md set filetype=markdown

    " automatically resize panes on resize
    autocmd VimResized * exe 'normal! \<c-w>='
    autocmd BufWritePost .vimrc source %
    autocmd BufWritePost .vimrc.local source %
    " save all files on focus lost, ignoring warnings about untitled buffers
    autocmd FocusLost * silent! wa
endif
" }}}

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Plugin settings
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" supertab {{{

"let g:SuperTabMappingForward="<tab>"
"let g:SuperTabMappingBackward="<S-Tab>"
" let g:SuperTabDefaultCompletionType = "<c-n>"
let g:SuperTabDefaultCompletionType = "context"
let g:SuperTabClosePreviewOnPopupClose = 1
" }}}

" snipMate {{{
" let g:snipMate = {}
" let g:snipMate.scope_aliases = {}
" let g:snipMate.scope_aliases['ruby'] = 'ruby,rails'
"
" imap <C-J> <Plug>snipMateNextOrTrigger
" smap <C-J> <Plug>snipMateNextOrTrigger
" }}}

" vim-php-namespace {{{
function! IPhpInsertUse()
    call PhpInsertUse()
    call feedkeys('a',  'n')
endfunction
" autocmd FileType php inoremap <Leader>u <Esc>:call IPhpInsertUse()<CR>
autocmd FileType php noremap <Leader>u :call PhpInsertUse()<CR>

function! IPhpExpandClass()
    call PhpExpandClass()
    call feedkeys('a', 'n')
endfunction
" autocmd FileType php inoremap <Leader>e <Esc>:call IPhpExpandClass()<CR>
autocmd FileType php noremap <Leader>e :call PhpExpandClass()<CR>

" autocmd FileType php inoremap <Leader>s <Esc>:call PhpSortUse()<CR>
autocmd FileType php noremap <Leader>s :call PhpSortUse()<CR>
""" }}}

" NERDTree {{{
" close NERDTree after a file is opened
let g:NERDTreeQuitOnOpen=0
" show hidden files in NERDTree
let NERDTreeShowHidden=1
" remove some files by extension
let NERDTreeIgnore = ['\.js.map$']
" Toggle NERDTree
nnoremap <silent> <leader>k :NERDTreeToggle<cr>
" expand to the path of the file in the current buffer
nnoremap <silent> <leader>y :NERDTreeFind<cr>
"}}}

" airline {{{
set ttimeoutlen=50

let g:airline_powerline_fonts=1
let g:airline_left_sep='ÓÉÄ'
let g:airline_right_sep='ÓÉÇ'
" let g:airline_theme='luna'
"let g:airline_theme='powerlineish'
" let g:airline_theme='badwolf'
let g:airline_theme='gruvbox'
" let g:airline_theme='papercolor'
if !exists('g:airline_symbols')
  let g:airline_symbols = {}
endif
let g:airline#extensions#tabline#enabled = 1
let g:airline#extensions#hunks#enabled = 1
"let g:airline_extensions = ['ctrlp']

call airline#parts#define_function('ALE', 'ALEGetStatusLine')
call airline#parts#define_condition('ALE', 'exists("*ALEGetStatusLine")')
call airline#parts#define_function('gutentags','gutentags#statusline')
call airline#parts#define_condition('gutentags', 'exists("*gutentags#statusline")')
let g:airline_section_error = airline#section#create_right(['ALE', 'gutentags'])

" autocmd VimEnter,BufWinEnter *.php :AirlineRefresh
autocmd! BufWritePost .vimrc,_vimrc,vimrc
        \ source $MYVIMRC | AirlineRefresh
""" }}}

" ctrlp {{{
let g:ctrlp_map = '<c-p>'
let g:ctrlp_cmd = 'CtrlP'

if exists("g:ctrl_user_command")
  unlet g:ctrlp_user_command
endif

let g:ctrlp_working_path_mode = 'ra'
let g:ctrlp_custom_ignore = '\v[\/]\.(git|hg|svn|rsync_cache)$'
let g:ctrlp_clear_cache_on_exit=0
let g:ctrlp_user_command = ['.git/', 'git --git-dir=%s/.git ls-files -oc --exclude-standard']
""" }}}

" Vim-php-cs-fixer {{{
" If php-cs-fixer is in $PATH, you don't need to define line below
" let g:php_cs_fixer_path = "~/php-cs-fixer.phar" " define the path to the php-cs-fixer.phar
" let g:php_cs_fixer_level = "symfony"              " which level ?
let g:php_cs_fixer_level = "all"              " which level ?
" let g:php_cs_fixer_config = "default"             " configuration
"let g:php_cs_fixer_config_file = '.php_cs'       " configuration file
" let g:php_cs_fixer_php_path = "php"               " Path to PHP
" If you want to define specific fixers:
"let g:php_cs_fixer_fixers_list = "linefeed,short_tag,indentation"
let g:php_cs_fixer_enable_default_mapping = 1     " Enable the mapping by default (<leader>pcd)
let g:php_cs_fixer_dry_run = 0                    " Call command with dry-run option
let g:php_cs_fixer_verbose = 0                    " Return the output of command if 1, else an inline information.
""" }}}

" Neocomplete {{{
"Note: This option must set it in .vimrc(_vimrc).  NOT IN .gvimrc(_gvimrc)!
" Disable AutoComplPop.
let g:acp_enableAtStartup = 0
" Use neocomplete.
let g:neocomplete#enable_at_startup = 1
" Use smartcase.
let g:neocomplete#enable_smart_case = 1
" Set minimum syntax keyword length.
let g:neocomplete#sources#syntax#min_keyword_length = 3
let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'
let g:neocomplcache_disable_auto_complete = 1


" Define dictionary.
let g:neocomplete#sources#dictionary#dictionaries = {
    \ 'default' : '',
    \ 'php' : $HOME.'/.vim/php.dict',
    \ }

" Define keyword.
if !exists('g:neocomplete#keyword_patterns')
    let g:neocomplete#keyword_patterns = {}
endif
let g:neocomplete#keyword_patterns['default'] = '\h\w*'

" Plugin key-mappings.
inoremap <expr><C-g>     neocomplete#undo_completion()
inoremap <expr><C-l>     neocomplete#complete_common_string()

" Recommended key-mappings.
" <CR>: close popup and save indent.
inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
function! s:my_cr_function()
  return (pumvisible() ? "\<C-y>" : "" ) . "\<CR>"
  " For no inserting <CR> key.
  "return pumvisible() ? "\<C-y>" : "\<CR>"
endfunction
" <TAB>: completion.
inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
" <C-h>, <BS>: close popup and delete backword char.
inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
" Close popup by <Space>.
"inoremap <expr><Space> pumvisible() ? "\<C-y>" : "\<Space>"

" AutoComplPop like behavior.
"let g:neocomplete#enable_auto_select = 1

" Shell like behavior(not recommended).
"set completeopt+=longest
"let g:neocomplete#enable_auto_select = 1
"let g:neocomplete#disable_auto_complete = 1
"inoremap <expr><TAB>  pumvisible() ? "\<Down>" : "\<C-x>\<C-u>"

" Enable omni completion.
autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

" Enable heavy omni completion.
if !exists('g:neocomplete#sources#omni#input_patterns')
  let g:neocomplete#sources#omni#input_patterns = {}
endif
" let g:neocomplete#sources#omni#input_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
" let g:neocomplete#force_omni_input_patterns = {}
" let g:neocomplete#force_omni_input_patterns.php = '\h\w*\|[^- \t]->\w*'

"let g:neocomplete#sources#omni#input_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
"let g:neocomplete#sources#omni#input_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'

" For perlomni.vim setting.
" https://github.com/c9s/perlomni.vim
" let g:neocomplete#sources#omni#input_patterns.perl = '\h\w*->\h\w*\|\h\w*::'

let g:neocomplete#sources#omni#input_patterns.ruby = '[^. *\t]\.\h\w*\|\h\w*::'
autocmd FileType ruby setlocal omnifunc=rubycomplete#Complete
" }}}

" terryma/vim-multiple-cursors {{{
" Prevent conflict with Neocomplete
" Called once right before you start selecting multiple cursors
function! Multiple_cursors_before()
  if exists(':NeoCompleteLock')==2
    exe 'NeoCompleteLock'
  endif
endfunction

" Called once only when the multiple selection is canceled (default <Esc>)
function! Multiple_cursors_after()
  if exists(':NeoCompleteUnlock')==2
    exe 'NeoCompleteUnlock'
  endif
endfunction
" }}}

" Shougo/deoplete.nvim {{{
" let g:deoplete#enable_at_startup = 1
" }}}

" UltiSnips {{{
" Trigger configuration. Do not use <tab> if you use https://github.com/Valloric/YouCompleteMe.
let g:UltiSnipsExpandTrigger="<c-k>"
let g:UltiSnipsJumpForwardTrigger="<c-k>"
let g:UltiSnipsJumpBackwardTrigger="<c-j>"

" If you want :UltiSnipsEdit to split your window.
let g:UltiSnipsEditSplit="vertical"

" make vim recognizing snippets dir
" use different snippets dir
" let g:UltiSnipsSnippetsDir='~/.vim/my-snippets/'
" let g:UltiSnipsSnippetDirectories=["UltiSnips"]
" }}}

" godlygeek/tabular {{{
nnoremap <Leader>= :Tabularize /=>\?<CR>
vnoremap <Leader>= :Tabularize /=>\?<CR>
nnoremap <Leader>: :Tabularize /:\zs<CR>
vnoremap <Leader>: :Tabularize /:\zs<CR>
" }}}

" luochen1990/rainbow {{{
" let g:rainbow_active = 1
" }}}

" benmills/vimux {{{
" Run the current file with rspec
map <Leader>rb :call VimuxRunCommand("clear; rspec " . bufname("%"))<CR>

" Prompt for a command to run
map <Leader>vp :VimuxPromptCommand<CR>

" Run last command executed by VimuxRunCommand
map <Leader>vl :VimuxRunLastCommand<CR>

" Inspect runner pane
map <Leader>vi :VimuxInspectRunner<CR>

" Close vim tmux runner opened by VimuxRunCommand
map <Leader>vq :VimuxCloseRunner<CR>

" Interrupt any command running in the runner pane
map <Leader>vx :VimuxInterruptRunner<CR>

" Zoom the runner pane (use <bind-key> z to restore runner pane)
map <Leader>vz :call VimuxZoomRunner()<CR>
" }}}

" tobyS/pdv {{{
let g:pdv_template_dir = $HOME ."/.vim/plugged/pdv/templates_snip"
nnoremap <Leader>doc :call pdv#DocumentWithSnip()<CR>
"}}}

" vim-syntastic/syntastic {{{
" set statusline+=%#warningmsg#
" set statusline+=%{SyntasticStatuslineFlag()}
" set statusline+=%*
"
" let g:syntastic_always_populate_loc_list = 1
" let g:syntastic_auto_loc_list = 1
" let g:syntastic_check_on_open = 1
" let g:syntastic_check_on_wq = 0
"
" let g:syntastic_php_checkers = ['php']
"}}}

" w0rp/ale {{{

let g:ale_set_quickfix = 1
let g:ale_statusline_format = ['‚®â %d', '‚ö† %d', '‚¨• ok']
let g:ale_linters = {
\   'php': ['php'],
\   'javascript': [],
\   'ruby': ['ruby'],
\}
" let g:ale_open_list = 1
" let g:ale_keep_list_window_open = 1
let g:ale_echo_msg_error_str = 'E'
let g:ale_echo_msg_warning_str = 'W'
let g:ale_echo_msg_format = '[%linter%] %s [%severity%]'


" set statusline+=%{ALEGetStatusLine()}
" set statusline+=%*

nmap <silent> <C-k> <Plug>(ale_previous_wrap)
nmap <silent> <C-j> <Plug>(ale_next_wrap)
" }}}

" indentLine {{{
let g:indentLine_enabled = 0
"}}}

" ludovicchabant/vim-gutentags {{{
set statusline+=%{gutentags#statusline('[Generating...]')}
let g:gutentags_ctags_executable='exctags'
" As suggested in https://github.com/ludovicchabant/vim-gutentags/issues/113,
" to only update existing tags files and never create new ones:
let g:gutentags_project_root = ['tags']
let g:gutentags_add_default_project_roots = 0
" only need for debug.
" let g:gutentags_define_advanced_commands = 1
" }}}

" Shougo/denite.nvim {{{

" Change file_rec command.
call denite#custom#var('file_rec', 'command',
\ ['ag', '--follow', '--nocolor', '--nogroup', '-g', ''])

" Change mappings.
call denite#custom#map(
      \ 'insert',
      \ '<C-j>',
      \ '<denite:move_to_next_line>',
      \ 'noremap'
      \)
call denite#custom#map(
      \ 'insert',
      \ '<C-k>',
      \ '<denite:move_to_previous_line>',
      \ 'noremap'
      \)

" Change matchers.
call denite#custom#source(
\ 'file_mru', 'matchers', ['matcher_fuzzy', 'matcher_project_files'])
call denite#custom#source(
\ 'file_rec', 'matchers', ['matcher_cpsm'])

" Change sorters.
call denite#custom#source(
\ 'file_rec', 'sorters', ['sorter_sublime'])

" Add custom menus
let s:menus = {}

let s:menus.zsh = {
    \ 'description': 'Edit your import zsh configuration'
    \ }
let s:menus.zsh.file_candidates = [
    \ ['zshrc', '~/.zshrc'],
    \ ['zshenv', '~/.zshenv'],
    \ ]

let s:menus.my_commands = {
    \ 'description': 'Example commands'
    \ }
let s:menus.my_commands.command_candidates = [
    \ ['Split the window', 'vnew'],
    \ ['Open zsh menu', 'Denite menu:zsh'],
    \ ]

call denite#custom#var('menu', 'menus', s:menus)

" Ag command on grep source
call denite#custom#var('grep', 'command', ['ag'])
call denite#custom#var('grep', 'default_opts',
        \ ['-i', '--vimgrep'])
call denite#custom#var('grep', 'recursive_opts', [])
call denite#custom#var('grep', 'pattern_opt', [])
call denite#custom#var('grep', 'separator', ['--'])
call denite#custom#var('grep', 'final_opts', [])

call denite#custom#source('file_mru', 'converters',
      \ ['converter_relative_word'])

" Define alias
call denite#custom#alias('source', 'file_rec/git', 'file_rec')
call denite#custom#var('file_rec/git', 'command',
      \ ['git', 'ls-files', '-co', '--exclude-standard'])

" Change default prompt
" call denite#custom#option('default', 'prompt', '>')
call denite#custom#option('default', {
      \ 'prompt': '>',
      \ 'short_source_names': v:true
      \ })

" Change ignore_globs
call denite#custom#filter('matcher_ignore_globs', 'ignore_globs',
      \ [ '.git/', '.ropeproject/', '__pycache__/', 'tmp/', 'var/',
      \   'venv/', 'images/', '*.min.*', 'img/', 'fonts/'])

nnoremap [denite] <Nop>
nmap <C-u> [denite]

" -buffer-name=
nnoremap <silent> <leader>f  :<C-u>Denite file_rec/git -highlight-mode-insert=Search<CR>
nnoremap <silent> [denite]g  :<C-u>Denite grep -buffer-name=search-buffer-denite<CR>

" Denite grepÊ§úÁ¥¢ÁµêÊûú„ÇíÂÜçË°®Á§∫„Åô„Çã
nnoremap <silent> [denite]r :<C-u>Denite -resume -buffer-name=search-buffer-denite<CR>
" resume„Åó„ÅüÊ§úÁ¥¢ÁµêÊûú„ÅÆÊ¨°„ÅÆË°å„ÅÆÁµêÊûú„Å∏È£õ„Å∂
nnoremap <silent> [denite]n :<C-u>Denite -resume -buffer-name=search-buffer-denite -select=+1 -immediately<CR>
" resume„Åó„ÅüÊ§úÁ¥¢ÁµêÊûú„ÅÆÂâç„ÅÆË°å„ÅÆÁµêÊûú„Å∏È£õ„Å∂
nnoremap <silent> [denite]p :<C-u>Denite -resume -buffer-name=search-buffer-denite -select=-1 -immediately<CR>

" }}}

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Customize
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" show multi byte space {{{
"highlight ZenkakuSpace cterm=underline ctermfg=lightblue guibg=darkgray
"match ZenkakuSpace /„ÄÄ/
function! ZenkakuSpace()
    highlight ZenkakuSpace cterm=reverse ctermfg=DarkMagenta gui=reverse guifg=DarkMagenta
endfunction

if has('syntax')
    augroup ZenkakuSpace
        autocmd!
        autocmd ColorScheme       * call ZenkakuSpace()
        autocmd VimEnter,WinEnter * match ZenkakuSpace /„ÄÄ/
    augroup END
    call ZenkakuSpace()
endif
" }}}

" HiInterestingWord {{{
function! HiInterestingWord(n)
    " Save our location.
    normal! mz

    " Yank the current word into the z register.
    normal! "zyiw

    " Calculate an arbitrary match ID.  Hopefully nothing else is using it.
    let mid = 86750 + a:n

    " Clear existing matches, but don't worry if they don't exist.
    silent! call matchdelete(mid)

    " Construct a literal pattern that has to match at boundaries.
    let pat = '\V\<' . escape(@z, '\') . '\>'

    " Actually match the words.
    call matchadd("InterestingWord" . a:n, pat, 1, mid)

    " Move back to our original location.
    normal! `z
endfunction

nnoremap <silent> <leader>1 :call HiInterestingWord(1)<cr>
nnoremap <silent> <leader>2 :call HiInterestingWord(2)<cr>
nnoremap <silent> <leader>3 :call HiInterestingWord(3)<cr>
nnoremap <silent> <leader>4 :call HiInterestingWord(4)<cr>
nnoremap <silent> <leader>5 :call HiInterestingWord(5)<cr>
nnoremap <silent> <leader>6 :call HiInterestingWord(6)<cr>

hi def InterestingWord1 guifg=#000000 ctermfg=16 guibg=#ffa724 ctermbg=214
hi def InterestingWord2 guifg=#000000 ctermfg=16 guibg=#aeee00 ctermbg=154
hi def InterestingWord3 guifg=#000000 ctermfg=16 guibg=#8cffba ctermbg=121
hi def InterestingWord4 guifg=#000000 ctermfg=16 guibg=#b88853 ctermbg=137
hi def InterestingWord5 guifg=#000000 ctermfg=16 guibg=#ff9eb8 ctermbg=211
hi def InterestingWord6 guifg=#000000 ctermfg=16 guibg=#ff2c4b ctermbg=195
"}}}

" HtmlUnEscape {{{
function! HtmlUnEscape()
  silent s/&lt;/</eg
  silent s/&gt;/>/eg
  silent s/&amp;/\&/eg
endfunction

" nnoremap <silent> <leader>us :call HtmlUnEscape()<cr>
"}}}

" AlignPHPMap {{{
" format array
" function! AlignPHPMap() range
"      let sep = '=>'
"      let firstline = a:firstline
"      let lastline = a:lastline
"      let lines = {}
"      for lineno in range(firstline, lastline)
"           let lines[lineno] = match(getline(lineno), '\s*' . sep)
"      endfor
"      let maxLen = max(lines) + 1
"      for lineno in range(firstline, lastline)
"           if lines[lineno] != -1
"                let spaces = repeat(' ', maxLen - lines[lineno])
"                call setline(lineno, substitute(getline(lineno), '\s*' . sep . '\s*', spaces . sep . ' ', ''))
"           endif
"      endfor
" endfunction
"
" noremap <Leader>=> :call AlignPHPMap()<CR>
"
" " format =
" function! AlignPHPAssign() range
"      let sep = '='
"      let firstline = a:firstline
"      let lastline = a:lastline
"      let lines = {}
"      for lineno in range(firstline, lastline)
"           let lines[lineno] = match(getline(lineno), '\s*' . sep)
"      endfor
"      let maxLen = max(lines) + 1
"      for lineno in range(firstline, lastline)
"           if lines[lineno] != -1
"                let spaces = repeat(' ', maxLen - lines[lineno])
"                call setline(lineno, substitute(getline(lineno), '\s*' . sep . '\s*', spaces . sep . ' ', ''))
"           endif
"      endfor
" endfunction
"
" noremap <Leader>== :call AlignPHPAssign()<CR>
"}}}
